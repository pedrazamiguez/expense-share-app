name: Create App Release

on:
  push:
    branches:
      - main

jobs:
  build_and_release:
    name: Build and Release App
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      OER_APP_ID_RELEASE: ${{ secrets.OER_APP_ID_RELEASE }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Decode google-services.json
        run: echo "${{ secrets.GOOGLE_SERVICES_JSON_BASE64 }}" | base64 --decode > ${{ github.workspace }}/app/google-services.json

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      - name: Extract Version Name
        id: version_extractor
        run: |
          VERSION_NAME=$(grep "versionName" app/build.gradle.kts | head -n 1 | sed -e 's/versionName = "//' -e 's/"//' | tr -d '[:space:]')
          echo "VERSION_NAME=${VERSION_NAME}" >> $GITHUB_OUTPUT
          echo "App Version: $VERSION_NAME"

      - name: Generate Changelog
        id: changelog
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e  # Exit on any error
          
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          
          # Set up robust cleanup with trap
          cleanup() {
            echo "ðŸ§¹ Cleaning up temporary files..."
            rm -f /tmp/pr_data_develop.json /tmp/pr_data_main.json /tmp/changelog.txt /tmp/categories.json
          }
          trap cleanup EXIT
          
          echo "ðŸ” Determining version range..."
          CURRENT_VERSION="${{ steps.version_extractor.outputs.VERSION_NAME }}"
          LATEST_TAG=$(git tag -l "v*" | grep -v "v${CURRENT_VERSION}" | sort -V | tail -n 1)
          
          if [ -n "$LATEST_TAG" ]; then
            echo "ðŸ“Š Generating changelog from $LATEST_TAG to v$CURRENT_VERSION"
            LATEST_TAG_COMMIT=$(git rev-list -n 1 $LATEST_TAG)
            SEARCH_FILTER="merged:>$(git show -s --format=%cI $LATEST_TAG_COMMIT)"
          else
            echo "ðŸ“Š Generating changelog for all merged PRs (no previous tag found)"
            SEARCH_FILTER=""
          fi
          
          # Function to fetch PRs with better error handling and parameter validation
          fetch_prs() {
            local base_branch="$1"
            local output_file="$2"
          
            # Parameter validation
            if [ -z "$base_branch" ]; then
              echo "âŒ Error: base_branch parameter not provided to fetch_prs"
              return 2
            fi
            if [ -z "$output_file" ]; then
              echo "âŒ Error: output_file parameter not provided to fetch_prs"
              return 2
            fi
          
            local search_query="is:pr is:merged base:$base_branch"
            if [ -n "$SEARCH_FILTER" ]; then
              search_query="$search_query $SEARCH_FILTER"
            fi
          
            echo "ðŸ”„ Fetching PRs for base branch: $base_branch"
            echo "ðŸ“ Search query: $search_query"
          
            # Try to fetch PRs and validate JSON
            if gh pr list --search "$search_query" --json number,title,labels,mergedAt,author --limit 100 > "$output_file" 2>/dev/null; then
              # Validate JSON
              if jq empty "$output_file" 2>/dev/null; then
                echo "âœ… Successfully fetched PRs for $base_branch"
                return 0
              else
                echo "âš ï¸  Invalid JSON returned for $base_branch, using empty array"
                echo "[]" > "$output_file"
                return 1
              fi
            else
              echo "âš ï¸  Failed to fetch PRs for $base_branch, using empty array"
              echo "[]" > "$output_file"
              return 1
            fi
          }
          
          # Fetch PRs from both branches
          echo "ðŸ” Fetching PRs from develop branch..."
          fetch_prs "develop" "/tmp/pr_data_develop.json"
          
          echo "ðŸ” Fetching PRs from main branch..."
          fetch_prs "main" "/tmp/pr_data_main.json"
          
          # Debug: Show what we got
          echo "ðŸ“‹ Develop PRs data:"
          cat /tmp/pr_data_develop.json | head -5 || echo "No develop data"
          echo "ðŸ“‹ Main PRs data:"  
          cat /tmp/pr_data_main.json | head -5 || echo "No main data"
          
          # Debug: Show raw PR count
          DEVELOP_PR_COUNT=$(cat /tmp/pr_data_develop.json | jq '. | length')
          MAIN_PR_COUNT=$(cat /tmp/pr_data_main.json | jq '. | length')
          echo "ðŸ” Raw PR counts - Develop: $DEVELOP_PR_COUNT, Main: $MAIN_PR_COUNT"
          
          # Process PR data and generate structured changelog
          echo "ðŸ”„ Processing PR data..."
          PROCESSED_DATA=$(cat /tmp/pr_data_develop.json /tmp/pr_data_main.json | jq -s --arg current_version "$CURRENT_VERSION" '
            # Combine arrays and remove duplicates
            add | unique_by(.number) |
            # Use positive filtering - only include PRs with relevant labels
            map(select(
              # Exclude sync, config, and release PRs
              (.labels | map(.name) | any(. == "sync") | not) and
              (.labels | map(.name) | any(. == "config") | not) and
              (.labels | map(.name) | any(. == "release") | not) and
              # Only include PRs with these specific labels (or if they have no relevant labels, we might still want them)
              (
                (.labels | map(.name) | any(. == "feature" or . == "bug" or . == "enhancement" or . == "hotfix")) or
                # Also include PRs that dont have exclusion labels but might be valid changes
                ((.labels | length) == 0)
              )
            )) |
            # Process each PR
            map({
              number: .number,
              title: .title,
              author: .author.login,
              mergedAt: .mergedAt,
              labels: [.labels[].name],
              # Extract issue number - handle EXSHAPP-NNNN format with exactly 4 digits
              issueNumber: (
                .title | 
                if test("\\\\[EXSHAPP-[0-9]{4}\\\\]") then
                  (match("\\\\[EXSHAPP-([0-9]+)\\\\]").captures[0].string | tonumber)
                else
                  null
                end
              ),
              # Clean title by removing the issue reference
              cleanTitle: (
                .title |
                if test("\\\\[EXSHAPP-[0-9]{4}\\\\]:?\\\\s*") then
                  sub("\\\\[EXSHAPP-[0-9]{4}\\\\]:?\\\\s*"; "")
                else
                  .
                end
              ),
              # Check if this is a hotfix (by label OR branch name pattern OR merge commit pattern)
              isHotfix: (
                (.labels | any(. == "hotfix")) or
                (.title | test("hotfix/")) or
                (.title | test("hotfix")) or
                (.title | test("Fix release type"))
              ),
              # Determine category based on labels - prioritize specific labels
              category: (
                if (.labels | any(. == "hotfix")) or (.title | test("hotfix/")) or (.title | test("hotfix")) then "Fixed"
                elif (.labels | any(. == "bug")) or (.labels | any(. == "bugfix")) then "Fixed"
                elif (.labels | any(. == "feature")) then "Added"
                elif (.labels | any(. == "enhancement")) or (.labels | any(. == "improvement")) then "Improved"
                else "Other"
                end
              )
            }) |
            # Sort by PR number
            sort_by(.number) |
            # Group by category and generate formatted entries
            {
              prs: .,
              totalCount: length,
              hasHotfixes: (map(.isHotfix) | any),
              releaseType: (
                if (map(.isHotfix) | any) then "hotfix"
                elif (map(.category) | map(. == "Fixed") | any) then "bugfix" 
                elif (map(.category) | map(. == "Added") | any) then "feature"
                else "maintenance"
                end
              ),
              categories: (
                group_by(.category) |
                map({
                  name: .[0].category,
                  count: length,
                  entries: map(
                    if .issueNumber then
                      "PR #\\(.number): Issue #\\(.issueNumber) - \\(.cleanTitle)"
                    else
                      "PR #\\(.number): \\(.cleanTitle)"
                    end
                  )
                }) |
                # Sort categories in preferred order
                sort_by(
                  if .name == "Added" then 1
                  elif .name == "Fixed" then 2
                  elif .name == "Improved" then 3
                  else 4
                  end
                )
              )
            }
          ')
          
          # Debug: Show processed data
          echo "ðŸ” Debug - Processed PR data:"
          echo "$PROCESSED_DATA" | jq -r '.prs[] | "PR #\(.number): \(.title) | Labels: \(.labels | join(",")) | isHotfix: \(.isHotfix) | Category: \(.category)"'
          
          # Extract data from JSON
          TOTAL_PRS=$(echo "$PROCESSED_DATA" | jq -r '.totalCount')
          RELEASE_TYPE=$(echo "$PROCESSED_DATA" | jq -r '.releaseType')
          HAS_HOTFIXES=$(echo "$PROCESSED_DATA" | jq -r '.hasHotfixes')
          
          echo "ðŸ“ˆ Found $TOTAL_PRS PRs for this release (type: $RELEASE_TYPE)"
          echo "ðŸ” Debug - Has hotfixes: $HAS_HOTFIXES"
          
          # Build changelog - robust approach that handles multi-line JSON
          CHANGELOG_FILE="/tmp/changelog.txt"
          
          if [ "$TOTAL_PRS" -gt 0 ]; then
            # Add release summary with previous version link
            if [ -n "$LATEST_TAG" ]; then
              echo "**$TOTAL_PRS changes** since $LATEST_TAG" > "$CHANGELOG_FILE"
            else
              echo "**$TOTAL_PRS changes** in this release" > "$CHANGELOG_FILE"
            fi
          
            # Add release type indicator
            case "$RELEASE_TYPE" in
              "hotfix") echo -n " ðŸ”¥" >> "$CHANGELOG_FILE" ;;
              "bugfix") echo -n " ðŸ›" >> "$CHANGELOG_FILE" ;;
              "feature") echo -n " âœ¨" >> "$CHANGELOG_FILE" ;;
            esac
          
            echo -e "\n" >> "$CHANGELOG_FILE"
          
            # Process categories directly with jq - no intermediate files
            echo "ðŸ” Processing changelog categories..."
          
            # Get the number of categories
            CATEGORY_COUNT=$(echo "$PROCESSED_DATA" | jq -r '.categories | map(select(.name != "Other")) | length')
            echo "ðŸ“‹ Found $CATEGORY_COUNT categories to process"
          
            # Only process categories if we have any
            if [ "$CATEGORY_COUNT" -gt 0 ]; then
              # Process each category using array index
              for i in $(seq 0 $((CATEGORY_COUNT - 1))); do
                CATEGORY_NAME=$(echo "$PROCESSED_DATA" | jq -r --argjson idx "$i" '.categories | map(select(.name != "Other"))[$idx].name')
                CATEGORY_COUNT_ITEMS=$(echo "$PROCESSED_DATA" | jq -r --argjson idx "$i" '.categories | map(select(.name != "Other"))[$idx].count')
          
                if [ "$CATEGORY_NAME" != "null" ] && [ -n "$CATEGORY_NAME" ]; then
                  echo "ðŸ“ Processing $CATEGORY_NAME section ($CATEGORY_COUNT_ITEMS items)..."
          
                  # Add section header
                  echo "#### $CATEGORY_NAME" >> "$CHANGELOG_FILE"
                  echo "" >> "$CHANGELOG_FILE"
          
                  # Get entries for this category
                  ENTRIES=$(echo "$PROCESSED_DATA" | jq -r --argjson idx "$i" '.categories | map(select(.name != "Other"))[$idx].entries[]')
          
                  # Add each entry
                  while IFS= read -r entry; do
                    if [ -n "$entry" ] && [ "$entry" != "null" ]; then
                      echo "$entry" >> "$CHANGELOG_FILE"
                    fi
                  done <<< "$ENTRIES"
          
                  echo "" >> "$CHANGELOG_FILE"
                fi
              done
            else
              echo "âš ï¸  No categories found, adding simple PR list"
              # Fallback: add PRs without categorization
              echo "$PROCESSED_DATA" | jq -r '.prs[] | "#\(.number): \(.cleanTitle)"' >> "$CHANGELOG_FILE"
            fi
          else
            echo "No new changes since the last release." > "$CHANGELOG_FILE"
          fi
          
          # Read the final changelog
          CHANGELOG=$(cat "$CHANGELOG_FILE")
          
          echo "âœ… Generated changelog with $TOTAL_PRS PRs"
          echo "ðŸ“„ Changelog preview:"
          echo "$CHANGELOG" | head -20
          
          # Output the changelog
          {
            echo "CHANGELOG<<EOF"
            echo "$CHANGELOG"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          # Also output release metadata for potential use in other steps
          {
            echo "RELEASE_TYPE<<EOF"
            echo "$RELEASE_TYPE"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          {
            echo "TOTAL_PRS<<EOF"  
            echo "$TOTAL_PRS"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Decode Keystore
        run: |
          mkdir -p ${{ github.workspace }}/keystore
          echo "${{ secrets.RELEASE_KEYSTORE_BASE64 }}" | base64 --decode > ${{ github.workspace }}/keystore/release.keystore

      - name: Build Release App (APK)
        env:
          SIGNING_STORE_FILE: ${{ github.workspace }}/keystore/release.keystore
          SIGNING_KEY_ALIAS: ${{ secrets.SIGNING_KEY_ALIAS }}
          SIGNING_KEY_PASSWORD: ${{ secrets.SIGNING_KEY_PASSWORD }}
          SIGNING_STORE_PASSWORD: ${{ secrets.SIGNING_STORE_PASSWORD }}
        run: ./gradlew assembleRelease

      - name: Rename APK with version
        run: |
          VERSION_NAME=${{ steps.version_extractor.outputs.VERSION_NAME }}
          mv app/build/outputs/apk/release/app-release.apk app/build/outputs/apk/release/app-release-${VERSION_NAME}.apk

      - name: Collect Commit Metadata
        id: commit_meta
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          COMMIT_AUTHOR=$(git log -1 --pretty=format:'%an')
          echo "COMMIT_MSG=${COMMIT_MSG}" >> $GITHUB_OUTPUT
          echo "COMMIT_AUTHOR=${COMMIT_AUTHOR}" >> $GITHUB_OUTPUT

      - name: Create and Push Git Tag
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          git tag -f v${{ steps.version_extractor.outputs.VERSION_NAME }} ${{ github.sha }}
          git push origin -f v${{ steps.version_extractor.outputs.VERSION_NAME }}

      - name: Create GitHub Release and Upload Artifact
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version_extractor.outputs.VERSION_NAME }}
          name: "Release ${{ steps.version_extractor.outputs.VERSION_NAME }} (Build ${{ github.run_number }})"
          body: |
            ## ðŸš€ Release ${{ steps.version_extractor.outputs.VERSION_NAME }}

            **Release Type:** ${{ steps.changelog.outputs.RELEASE_TYPE }}
            **Total Changes:** ${{ steps.changelog.outputs.TOTAL_PRS }}
            **Build Number:** ${{ github.run_number }}
            **Triggered by:** Push to main

            ---

            ### ðŸ“‹ Changelog
            ${{ steps.changelog.outputs.CHANGELOG }}

            ---

            ### ðŸ“¦ Build Information
            - **Latest Commit:** ${{ github.sha }}
            - **Message:** ${{ steps.commit_meta.outputs.COMMIT_MSG }}
            - **Author:** ${{ steps.commit_meta.outputs.COMMIT_AUTHOR }}
            - **Build Time:** ${{ github.event.head_commit.timestamp }}

            ### ðŸ“± Installation
            Download the APK file below and install it on your Android device.

            > **Note:** Make sure to enable "Install from unknown sources" in your device settings.
          draft: false
          prerelease: false
          files: |
            app/build/outputs/apk/release/app-release-${{ steps.version_extractor.outputs.VERSION_NAME }}.apk
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
