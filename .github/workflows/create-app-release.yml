name: Create App Release

on:
  push:
    branches:
      - main

jobs:
  build_and_release:
    name: Build and Release App
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      OER_APP_ID_RELEASE: ${{ secrets.OER_APP_ID_RELEASE }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Decode google-services.json
        run: echo "${{ secrets.GOOGLE_SERVICES_JSON_BASE64 }}" | base64 --decode > ${{ github.workspace }}/app/google-services.json

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      - name: Decode Keystore
        run: |
          mkdir -p ${{ github.workspace }}/keystore
          echo "${{ secrets.RELEASE_KEYSTORE_BASE64 }}" | base64 --decode > ${{ github.workspace }}/keystore/release.keystore

      - name: Build Release App (APK)
        env:
          SIGNING_STORE_FILE: ${{ github.workspace }}/keystore/release.keystore
          SIGNING_KEY_ALIAS: ${{ secrets.SIGNING_KEY_ALIAS }}
          SIGNING_KEY_PASSWORD: ${{ secrets.SIGNING_KEY_PASSWORD }}
          SIGNING_STORE_PASSWORD: ${{ secrets.SIGNING_STORE_PASSWORD }}
        run: ./gradlew assembleRelease

      - name: Extract Version Name
        id: version_extractor
        run: |
          VERSION_NAME=$(grep "versionName" app/build.gradle.kts | head -n 1 | sed -e 's/versionName = "//' -e 's/"//' | tr -d '[:space:]')
          echo "VERSION_NAME=${VERSION_NAME}" >> $GITHUB_OUTPUT
          echo "App Version: $VERSION_NAME"

      - name: Rename APK with version
        run: |
          VERSION_NAME=${{ steps.version_extractor.outputs.VERSION_NAME }}
          mv app/build/outputs/apk/release/app-release.apk app/build/outputs/apk/release/app-release-${VERSION_NAME}.apk

      - name: Generate Changelog
        id: changelog
        run: |
          set -e  # Exit on any error
          
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          
          echo "🔍 Determining version range..."
          CURRENT_VERSION="${{ steps.version_extractor.outputs.VERSION_NAME }}"
          LATEST_TAG=$(git tag -l "v*" | grep -v "v${CURRENT_VERSION}" | sort -V | tail -n 1)
          
          if [ -n "$LATEST_TAG" ]; then
            echo "📊 Generating changelog from $LATEST_TAG to v$CURRENT_VERSION"
            LATEST_TAG_COMMIT=$(git rev-list -n 1 $LATEST_TAG)
            SEARCH_FILTER="merged:>$(git show -s --format=%cI $LATEST_TAG_COMMIT)"
          else
            echo "📊 Generating changelog for all merged PRs (no previous tag found)"
            SEARCH_FILTER=""
          fi
          
          # Function to fetch PRs with error handling
          fetch_prs() {
            local base_branch="$1"
            local search_query="is:pr is:merged base:$base_branch"
            if [ -n "$SEARCH_FILTER" ]; then
              search_query="$search_query $SEARCH_FILTER"
            fi
            
            echo "🔄 Fetching PRs for base branch: $base_branch"
            if ! gh pr list --search "$search_query" --json number,title,labels,mergedAt,author --limit 100 2>/dev/null; then
              echo "⚠️  Warning: Failed to fetch PRs for base branch $base_branch"
              echo "[]"
            fi
          }
          
          # Fetch PRs from both branches
          fetch_prs "develop" > /tmp/pr_data_develop.json
          fetch_prs "main" > /tmp/pr_data_main.json
          
          # Process PR data and generate structured changelog
          PROCESSED_DATA=$(cat /tmp/pr_data_develop.json /tmp/pr_data_main.json | jq -s --arg current_version "$CURRENT_VERSION" '
            # Combine arrays and remove duplicates
            add | unique_by(.number) |
            # Filter out sync and internal PRs
            map(select(
              (.labels | map(.name) | index("sync") | not) and
              (.labels | map(.name) | index("config") | not)
            )) |
            # Process each PR
            map({
              number: .number,
              title: .title,
              author: .author.login,
              mergedAt: .mergedAt,
              labels: [.labels[].name],
              # Extract issue number more reliably
              issueNumber: (
                .title | 
                if test("\\[EXSHAPP-[0-9]{4}\\]") then
                  (match("\\[EXSHAPP-([0-9]+)\\]").captures[0].string | tonumber)
                else
                  null
                end
              ),
              # Clean title by removing the issue reference
              cleanTitle: (
                .title |
                if test("\\[EXSHAPP-[0-9]{4}\\]:?\\s*") then
                  sub("\\[EXSHAPP-[0-9]{4}\\]:?\\s*"; "")
                else
                  .
                end
              ),
              # Determine category based on labels
              category: (
                .labels |
                if index("feature") then "Added"
                elif (index("hotfix") or index("bug")) then "Fixed"  
                elif index("enhancement") then "Improved"
                else "Other"
                end
              ),
              # Check if this is a hotfix
              isHotfix: (.labels | index("hotfix") != null)
            }) |
            # Sort by PR number
            sort_by(.number) |
            # Group by category and generate formatted entries
            {
              prs: .,
              totalCount: length,
              hasHotfixes: (map(.isHotfix) | any),
              releaseType: (
                if (map(.isHotfix) | any) then "hotfix"
                elif (map(.category == "Fixed") | any) then "bugfix" 
                elif (map(.category == "Added") | any) then "feature"
                else "maintenance"
                end
              ),
              categories: (
                group_by(.category) |
                map({
                  name: .[0].category,
                  count: length,
                  entries: map(
                    if .issueNumber then
                      "#\(.number): #\(.issueNumber) - \(.cleanTitle)"
                    else
                      "#\(.number): \(.cleanTitle)"
                    end
                  )
                }) |
                # Sort categories in preferred order
                sort_by(
                  if .name == "Added" then 1
                  elif .name == "Fixed" then 2
                  elif .name == "Improved" then 3
                  else 4
                  end
                )
              )
            }
          ')
          
          # Extract data from JSON
          TOTAL_PRS=$(echo "$PROCESSED_DATA" | jq -r '.totalCount')
          RELEASE_TYPE=$(echo "$PROCESSED_DATA" | jq -r '.releaseType')
          HAS_HOTFIXES=$(echo "$PROCESSED_DATA" | jq -r '.hasHotfixes')
          
          echo "📈 Found $TOTAL_PRS PRs for this release (type: $RELEASE_TYPE)"
          
          # Build changelog
          CHANGELOG=""
          
          if [ "$TOTAL_PRS" -gt 0 ]; then
            # Add release summary with previous version link
            if [ -n "$LATEST_TAG" ]; then
              CHANGELOG="**$TOTAL_PRS changes** since $LATEST_TAG"
            else
              CHANGELOG="**$TOTAL_PRS changes** in this release"
            fi
            
            # Add release type indicator
            case "$RELEASE_TYPE" in
              "hotfix") CHANGELOG="$CHANGELOG 🔥\n" ;;
              "bugfix") CHANGELOG="$CHANGELOG 🐛\n" ;;
              "feature") CHANGELOG="$CHANGELOG ✨\n" ;;
              *) CHANGELOG="$CHANGELOG\n" ;;
            esac
            
            CHANGELOG="$CHANGELOG\n"
            
            # Process each category
            echo "$PROCESSED_DATA" | jq -r '.categories[] | select(.name != "Other") | @base64' | while IFS= read -r category_b64; do
              category_data=$(echo "$category_b64" | base64 --decode)
              category_name=$(echo "$category_data" | jq -r '.name')
              category_count=$(echo "$category_data" | jq -r '.count')
              
              echo "📝 Processing $category_name section ($category_count items)..."
              
              # Add section header
              section_content="#### $category_name\n\n"
              
              # Add entries
              echo "$category_data" | jq -r '.entries[]' | while IFS= read -r entry; do
                section_content="${section_content}$entry\n"
              done
              
              section_content="${section_content}\n"
              echo "$section_content" >> /tmp/changelog_sections.txt
            done
            
            # Read accumulated sections (fix for subshell issue)
            if [ -f /tmp/changelog_sections.txt ]; then
              SECTIONS_CONTENT=$(cat /tmp/changelog_sections.txt)
              CHANGELOG="${CHANGELOG}${SECTIONS_CONTENT}"
              rm -f /tmp/changelog_sections.txt
            fi
          else
            CHANGELOG="No new changes since the last release."
          fi
          
          # Clean up temporary files
          rm -f /tmp/pr_data_develop.json /tmp/pr_data_main.json
          
          echo "✅ Generated changelog with $TOTAL_PRS PRs"
          
          # Output the changelog
          {
            echo "CHANGELOG<<EOF"
            echo -e "$CHANGELOG"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          # Also output release metadata for potential use in other steps
          {
            echo "RELEASE_TYPE<<EOF"
            echo "$RELEASE_TYPE"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          {
            echo "TOTAL_PRS<<EOF"  
            echo "$TOTAL_PRS"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Collect Commit Metadata
        id: commit_meta
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          COMMIT_AUTHOR=$(git log -1 --pretty=format:'%an')
          echo "COMMIT_MSG=${COMMIT_MSG}" >> $GITHUB_OUTPUT
          echo "COMMIT_AUTHOR=${COMMIT_AUTHOR}" >> $GITHUB_OUTPUT

      - name: Create and Push Git Tag
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          git tag -f v${{ steps.version_extractor.outputs.VERSION_NAME }} ${{ github.sha }}
          git push origin -f v${{ steps.version_extractor.outputs.VERSION_NAME }}

      - name: Create GitHub Release and Upload Artifact
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version_extractor.outputs.VERSION_NAME }}
          name: "Release ${{ steps.version_extractor.outputs.VERSION_NAME }} (Build ${{ github.run_number }})"
          body: |
            ## 🚀 Release ${{ steps.version_extractor.outputs.VERSION_NAME }}

            **Release Type:** ${{ steps.changelog.outputs.RELEASE_TYPE }}
            **Total Changes:** ${{ steps.changelog.outputs.TOTAL_PRS }}
            **Build Number:** ${{ github.run_number }}
            **Triggered by:** Push to main

            ---

            ### 📋 Changelog
            ${{ steps.changelog.outputs.CHANGELOG }}

            ---

            ### 📦 Build Information
            - **Latest Commit:** ${{ github.sha }}
            - **Message:** ${{ steps.commit_meta.outputs.COMMIT_MSG }}
            - **Author:** ${{ steps.commit_meta.outputs.COMMIT_AUTHOR }}
            - **Build Time:** ${{ github.event.head_commit.timestamp }}

            ### 📱 Installation
            Download the APK file below and install it on your Android device.

            > **Note:** Make sure to enable "Install from unknown sources" in your device settings.
          draft: false
          prerelease: false
          files: |
            app/build/outputs/apk/release/app-release-${{ steps.version_extractor.outputs.VERSION_NAME }}.apk
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
