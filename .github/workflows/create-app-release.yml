name: Create App Release

on:
  push:
    branches:
      - main

jobs:
  build_and_release:
    name: Build and Release App
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      OER_APP_ID_RELEASE: ${{ secrets.OER_APP_ID_RELEASE }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Decode google-services.json
        run: echo "${{ secrets.GOOGLE_SERVICES_JSON_BASE64 }}" | base64 --decode > ${{ github.workspace }}/app/google-services.json

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3

      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      - name: Decode Keystore
        run: |
          mkdir -p ${{ github.workspace }}/keystore
          echo "${{ secrets.RELEASE_KEYSTORE_BASE64 }}" | base64 --decode > ${{ github.workspace }}/keystore/release.keystore

      - name: Build Release App (APK)
        env:
          SIGNING_STORE_FILE: ${{ github.workspace }}/keystore/release.keystore
          SIGNING_KEY_ALIAS: ${{ secrets.SIGNING_KEY_ALIAS }}
          SIGNING_KEY_PASSWORD: ${{ secrets.SIGNING_KEY_PASSWORD }}
          SIGNING_STORE_PASSWORD: ${{ secrets.SIGNING_STORE_PASSWORD }}
        run: ./gradlew assembleRelease

      - name: Extract Version Name
        id: version_extractor
        run: |
          VERSION_NAME=$(grep "versionName" app/build.gradle.kts | head -n 1 | sed -e 's/versionName = "//' -e 's/"//' | tr -d '[:space:]')
          echo "VERSION_NAME=${VERSION_NAME}" >> $GITHUB_OUTPUT
          echo "App Version: $VERSION_NAME"

      - name: Rename APK with version
        run: |
          VERSION_NAME=${{ steps.version_extractor.outputs.VERSION_NAME }}
          mv app/build/outputs/apk/release/app-release.apk app/build/outputs/apk/release/app-release-${VERSION_NAME}.apk

      - name: Generate Changelog
        id: changelog
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e  # Exit on any error
          
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          
          # Set up robust cleanup with trap
          cleanup() {
            echo "üßπ Cleaning up temporary files..."
            rm -f /tmp/pr_data_develop.json /tmp/pr_data_main.json /tmp/changelog.txt /tmp/categories.json
          }
          trap cleanup EXIT
          
          echo "üîç Determining version range..."
          CURRENT_VERSION="${{ steps.version_extractor.outputs.VERSION_NAME }}"
          LATEST_TAG=$(git tag -l "v*" | grep -v "v${CURRENT_VERSION}" | sort -V | tail -n 1)
          
          if [ -n "$LATEST_TAG" ]; then
            echo "üìä Generating changelog from $LATEST_TAG to v$CURRENT_VERSION"
            LATEST_TAG_COMMIT=$(git rev-list -n 1 $LATEST_TAG)
            SEARCH_FILTER="merged:>$(git show -s --format=%cI $LATEST_TAG_COMMIT)"
          else
            echo "üìä Generating changelog for all merged PRs (no previous tag found)"
            SEARCH_FILTER=""
          fi
          
          # Function to fetch PRs with better error handling and parameter validation
          fetch_prs() {
            local base_branch="$1"
            local output_file="$2"
          
            # Parameter validation
            if [ -z "$base_branch" ]; then
              echo "‚ùå Error: base_branch parameter not provided to fetch_prs"
              return 2
            fi
            if [ -z "$output_file" ]; then
              echo "‚ùå Error: output_file parameter not provided to fetch_prs"
              return 2
            fi
          
            local search_query="is:pr is:merged base:$base_branch"
            if [ -n "$SEARCH_FILTER" ]; then
              search_query="$search_query $SEARCH_FILTER"
            fi
          
            echo "üîÑ Fetching PRs for base branch: $base_branch"
            echo "üìù Search query: $search_query"
          
            # Try to fetch PRs and validate JSON
            if gh pr list --search "$search_query" --json number,title,labels,mergedAt,author --limit 100 > "$output_file" 2>/dev/null; then
              # Validate JSON
              if jq empty "$output_file" 2>/dev/null; then
                echo "‚úÖ Successfully fetched PRs for $base_branch"
                return 0
              else
                echo "‚ö†Ô∏è  Invalid JSON returned for $base_branch, using empty array"
                echo "[]" > "$output_file"
                return 1
              fi
            else
              echo "‚ö†Ô∏è  Failed to fetch PRs for $base_branch, using empty array"
              echo "[]" > "$output_file"
              return 1
            fi
          }
          
          # Fetch PRs from both branches
          echo "üîç Fetching PRs from develop branch..."
          fetch_prs "develop" "/tmp/pr_data_develop.json"
          
          echo "üîç Fetching PRs from main branch..."
          fetch_prs "main" "/tmp/pr_data_main.json"
          
          # Debug: Show what we got
          echo "üìã Develop PRs data:"
          cat /tmp/pr_data_develop.json | head -5 || echo "No develop data"
          echo "üìã Main PRs data:"  
          cat /tmp/pr_data_main.json | head -5 || echo "No main data"
          
          # Debug: Show raw PR count
          DEVELOP_PR_COUNT=$(cat /tmp/pr_data_develop.json | jq '. | length')
          MAIN_PR_COUNT=$(cat /tmp/pr_data_main.json | jq '. | length')
          echo "üîç Raw PR counts - Develop: $DEVELOP_PR_COUNT, Main: $MAIN_PR_COUNT"
          
          # Process PR data and generate structured changelog
          echo "üîÑ Processing PR data..."
          PROCESSED_DATA=$(cat /tmp/pr_data_develop.json /tmp/pr_data_main.json | jq -s --arg current_version "$CURRENT_VERSION" '
            # Combine arrays and remove duplicates
            add | unique_by(.number) |
            # Filter out sync and internal PRs
            map(select(
              (.labels | map(.name) | index("sync") | not) and
              (.labels | map(.name) | index("config") | not)
            )) |
            # Process each PR
            map({
              number: .number,
              title: .title,
              author: .author.login,
              mergedAt: .mergedAt,
              labels: [.labels[].name],
              # Extract issue number more reliably
              issueNumber: (
                .title | 
                if test("\\[EXSHAPP-[0-9]{4}\\]") then
                  (match("\\[EXSHAPP-([0-9]+)\\]").captures[0].string | tonumber)
                else
                  null
                end
              ),
              # Clean title by removing the issue reference
              cleanTitle: (
                .title |
                if test("\\[EXSHAPP-[0-9]{4}\\]:?\\s*") then
                  sub("\\[EXSHAPP-[0-9]{4}\\]:?\\s*"; "")
                else
                  .
                end
              ),
              # Check if this is a hotfix (by label OR branch name pattern OR merge commit pattern)
              isHotfix: (
                (.labels | index("hotfix") != null) or
                (.title | test("hotfix/")) or
                (.title | test("hotfix")) or
                (.title | test("Fix release type"))
              ),
              # Determine category based on hotfix status first, then labels
              category: (
                if (
                  (.labels | index("hotfix") != null) or
                  (.title | test("hotfix/")) or
                  (.title | test("hotfix")) or
                  (.title | test("Fix release type"))
                ) then "Fixed"
                elif (.labels | index("feature") != null) then "Added"
                elif (.labels | index("bug") != null) then "Fixed"  
                elif (.labels | index("enhancement") != null) then "Improved"
                else "Other"
                end
              )
            }) |
            # Sort by PR number
            sort_by(.number) |
            # Group by category and generate formatted entries
            {
              prs: .,
              totalCount: length,
              hasHotfixes: (map(.isHotfix) | any),
              releaseType: (
                if (map(.isHotfix) | any) then "hotfix"
                elif (map(.category == "Fixed") | any) then "bugfix" 
                elif (map(.category == "Added") | any) then "feature"
                else "maintenance"
                end
              ),
              categories: (
                group_by(.category) |
                map({
                  name: .[0].category,
                  count: length,
                  entries: map(
                    if .issueNumber then
                      "#\(.number): #\(.issueNumber) - \(.cleanTitle)"
                    else
                      "#\(.number): \(.cleanTitle)"
                    end
                  )
                }) |
                # Sort categories in preferred order
                sort_by(
                  if .name == "Added" then 1
                  elif .name == "Fixed" then 2
                  elif .name == "Improved" then 3
                  else 4
                  end
                )
              )
            }
          ')
          
          # Debug: Show processed data
          echo "üîç Debug - Processed PR data:"
          echo "$PROCESSED_DATA" | jq -r '.prs[] | "PR #\(.number): \(.title) | Labels: \(.labels | join(",")) | isHotfix: \(.isHotfix) | Category: \(.category)"'
          
          # Extract data from JSON
          TOTAL_PRS=$(echo "$PROCESSED_DATA" | jq -r '.totalCount')
          RELEASE_TYPE=$(echo "$PROCESSED_DATA" | jq -r '.releaseType')
          HAS_HOTFIXES=$(echo "$PROCESSED_DATA" | jq -r '.hasHotfixes')
          
          echo "üìà Found $TOTAL_PRS PRs for this release (type: $RELEASE_TYPE)"
          echo "üîç Debug - Has hotfixes: $HAS_HOTFIXES"
          
          # Build changelog - simplified approach without base64 encoding
          CHANGELOG_FILE="/tmp/changelog.txt"
          
          if [ "$TOTAL_PRS" -gt 0 ]; then
            # Add release summary with previous version link
            if [ -n "$LATEST_TAG" ]; then
              echo "**$TOTAL_PRS changes** since $LATEST_TAG" > "$CHANGELOG_FILE"
            else
              echo "**$TOTAL_PRS changes** in this release" > "$CHANGELOG_FILE"
            fi
          
            # Add release type indicator
            case "$RELEASE_TYPE" in
              "hotfix") echo -n " üî•" >> "$CHANGELOG_FILE" ;;
              "bugfix") echo -n " üêõ" >> "$CHANGELOG_FILE" ;;
              "feature") echo -n " ‚ú®" >> "$CHANGELOG_FILE" ;;
            esac
          
            echo -e "\n" >> "$CHANGELOG_FILE"
          
            # Simplified category processing with better error handling
            echo "üîç Debug - Extracting categories..."
            if echo "$PROCESSED_DATA" | jq -r '.categories[] | select(.name != "Other")' > /tmp/categories.json 2>/dev/null; then
              echo "‚úÖ Categories extracted successfully"
          
              # Debug: Show categories file content
              echo "üîç Debug - Categories file content:"
              cat /tmp/categories.json || echo "Empty categories file"
          
              # Process each category line by line
              while IFS= read -r category_json; do
                if [ -n "$category_json" ] && echo "$category_json" | jq empty 2>/dev/null; then
                  category_name=$(echo "$category_json" | jq -r '.name')
                  category_count=$(echo "$category_json" | jq -r '.count')
          
                  echo "üìù Processing $category_name section ($category_count items)..."
          
                  # Add section header
                  echo "#### $category_name" >> "$CHANGELOG_FILE"
                  echo "" >> "$CHANGELOG_FILE"
          
                  # Add entries directly without complex variable handling
                  echo "$category_json" | jq -r '.entries[]' | while IFS= read -r entry; do
                    if [ -n "$entry" ]; then
                      echo "$entry" >> "$CHANGELOG_FILE"
                    fi
                  done
          
                  echo "" >> "$CHANGELOG_FILE"
                else
                  echo "‚ö†Ô∏è  Skipping invalid category JSON: $category_json"
                fi
              done < /tmp/categories.json
            else
              echo "‚ö†Ô∏è  Failed to extract categories, generating simple changelog"
              # Fallback: create simple changelog from PR titles
              echo "$PROCESSED_DATA" | jq -r '.prs[] | "#\(.number): \(.cleanTitle)"' >> "$CHANGELOG_FILE"
            fi
          else
            echo "No new changes since the last release." > "$CHANGELOG_FILE"
          fi
          
          # Read the final changelog
          CHANGELOG=$(cat "$CHANGELOG_FILE")
          
          echo "‚úÖ Generated changelog with $TOTAL_PRS PRs"
          echo "üìÑ Changelog preview:"
          echo "$CHANGELOG" | head -20
          
          # Output the changelog
          {
            echo "CHANGELOG<<EOF"
            echo "$CHANGELOG"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          # Also output release metadata for potential use in other steps
          {
            echo "RELEASE_TYPE<<EOF"
            echo "$RELEASE_TYPE"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          {
            echo "TOTAL_PRS<<EOF"  
            echo "$TOTAL_PRS"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Collect Commit Metadata
        id: commit_meta
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          COMMIT_AUTHOR=$(git log -1 --pretty=format:'%an')
          echo "COMMIT_MSG=${COMMIT_MSG}" >> $GITHUB_OUTPUT
          echo "COMMIT_AUTHOR=${COMMIT_AUTHOR}" >> $GITHUB_OUTPUT

      - name: Create and Push Git Tag
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          git tag -f v${{ steps.version_extractor.outputs.VERSION_NAME }} ${{ github.sha }}
          git push origin -f v${{ steps.version_extractor.outputs.VERSION_NAME }}

      - name: Create GitHub Release and Upload Artifact
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version_extractor.outputs.VERSION_NAME }}
          name: "Release ${{ steps.version_extractor.outputs.VERSION_NAME }} (Build ${{ github.run_number }})"
          body: |
            ## üöÄ Release ${{ steps.version_extractor.outputs.VERSION_NAME }}

            **Release Type:** ${{ steps.changelog.outputs.RELEASE_TYPE }}
            **Total Changes:** ${{ steps.changelog.outputs.TOTAL_PRS }}
            **Build Number:** ${{ github.run_number }}
            **Triggered by:** Push to main

            ---

            ### üìã Changelog
            ${{ steps.changelog.outputs.CHANGELOG }}

            ---

            ### üì¶ Build Information
            - **Latest Commit:** ${{ github.sha }}
            - **Message:** ${{ steps.commit_meta.outputs.COMMIT_MSG }}
            - **Author:** ${{ steps.commit_meta.outputs.COMMIT_AUTHOR }}
            - **Build Time:** ${{ github.event.head_commit.timestamp }}

            ### üì± Installation
            Download the APK file below and install it on your Android device.

            > **Note:** Make sure to enable "Install from unknown sources" in your device settings.
          draft: false
          prerelease: false
          files: |
            app/build/outputs/apk/release/app-release-${{ steps.version_extractor.outputs.VERSION_NAME }}.apk
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
